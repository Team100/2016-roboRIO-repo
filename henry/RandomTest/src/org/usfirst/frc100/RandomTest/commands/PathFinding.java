// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc100.RandomTest.commands;
import edu.wpi.first.wpilibj.command.Command;



import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import jaci.pathfinder.Pathfinder;
import jaci.pathfinder.Trajectory;
import jaci.pathfinder.Waypoint;
//import jaci.pathfinder.Waypoint;
import jaci.pathfinder.followers.EncoderFollower;
import jaci.pathfinder.modifiers.TankModifier;

import java.util.Timer;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.usfirst.frc100.RandomTest.Robot;
import org.usfirst.frc100.RandomTest.RobotMap;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;

/**
 *
 */
public class PathFinding extends Command {


	private boolean finish; 
	private int counter; 
	FalconPathPlanner path;
	Timer timer; 
	//boolean finish; 
	int countZero;
	EncoderFollower left; 
	EncoderFollower right; 
	double p; 
	double i; 
	double d; 
	double a;
	double p2; 
	double i2; 
	double d2; 
	double a2;
	Trajectory trajectory;
	
    public PathFinding() {
    	requires(Robot.driveTrain);
    	System.out.println("hi");
  
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	
    	finish = false;
    	counter = 0;
    	timer = new Timer();
    	Waypoint [] points = new Waypoint[]{
    			 new Waypoint(-4, -1, Pathfinder.d2r(0)),      // Waypoint @ x=-4, y=-1, exit angle=-45 degrees
    			    new Waypoint(-2, -2, 0),                        // Waypoint @ x=-2, y=-2, exit angle=0 radians
    			    new Waypoint(0, 0, 0)   
    			/*
    			new Waypoint(0, 0, Pathfinder.d2r(90)), //90, 45, 45, 90
    			new  Waypoint(1, 2, Pathfinder.d2r(45)),
    		
    			new Waypoint(3, 3, Pathfinder.d2r(45)),
    			new Waypoint(4, 5, Pathfinder.d2r(90)), */
    			//new Waypoint(-1, 3, 0),
    			//new Waypoint(-3, 8, 0), 
    		//	new Waypoint(-3, 10.5, 0), 
    			//new Waypoint(0, 0, 0), 
    			//new Waypoint(1, 0, 0)
    			
    	};
    	
    	p = Robot.prefs.getDouble("pathP",
				0);
    	i = Robot.prefs.getDouble("pathI",
				0);
    	d = Robot.prefs.getDouble("pathD",
				0);
    	a = Robot.prefs.getDouble("pathV",
				0);
    	
    	p2 = Robot.prefs.getDouble("pathP",
				0);
    	i2 = Robot.prefs.getDouble("pathI",
				0);
    	d2 = Robot.prefs.getDouble("PathD",
				0);
    	a2 = Robot.prefs.getDouble("PathV",
				0);
    	// Arguments:
    	// Fit Method:          HERMITE_CUBIC or HERMITE_QUINTIC
    	// Sample Count:        SAMPLES_HIGH (100 000)
//    	                      SAMPLES_LOW  (10 000)
//    	                      SAMPLES_FAST (1 000)
    	// Time Step:           0.05 Seconds
    	// Max Velocity:        1.7 m/s
    	// Max Acceleration:    2.0 m/s/s
    	// Max Jerk:            60.0 m/s/s/s
    	RobotMap.gyro.reset();
    	RobotMap.driveTrainTalonSRX1.setSelectedSensorPosition(0, 0, 0);
    	RobotMap.driveTrainTalonSRX2.setSelectedSensorPosition(0, 0, 0);
    	
    	Trajectory.Config config = new Trajectory.Config(Trajectory.FitMethod.HERMITE_CUBIC, Trajectory.Config.SAMPLES_HIGH, 0.1, 10.1, 16.7, 60);//17.08);
    	trajectory = Pathfinder.generate(points, config);
    
    	TankModifier modifier = new TankModifier(trajectory).modify(2.3);
        left = new EncoderFollower(modifier.getLeftTrajectory());
        right = new EncoderFollower(modifier.getRightTrajectory());
    	left.configureEncoder(RobotMap.driveTrainTalonSRX1.getSelectedSensorPosition(0), 8192, .3333);
    	right.configureEncoder(RobotMap.driveTrainTalonSRX2.getSelectedSensorPosition(0), 8192, .3333);
    	//left.configurePIDVA(p, i, d, 1 / 10.1, a);
    	//right.configurePIDVA(p2, i2, d2, 1 / 10.1, a2);
    	left.configurePIDVA(p, i, d, 0, a);
    	right.configurePIDVA(p2, i2, d2, 0, a2);
    	System.out.println("hi");
    	for (int i = 0; i < trajectory.length(); i++) {
    	    Trajectory.Segment seg = trajectory.get(i);
    	    
    	    System.out.printf("%f, %f\n",seg.x, seg.y);
    	    /*System.out.printf("%f,%f,%f,%f,%f,%f,%f,%f\n", 
    	        seg.dt, seg.x, seg.y, seg.position, seg.velocity, 
    	            seg.acceleration, seg.jerk, seg.heading); */
    	}
    
    	  
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	//System.out.println("hi");
    	 
    	SmartDashboard.putNumber("Pp", p);
    	SmartDashboard.putNumber("Pi", i);
    	SmartDashboard.putNumber("Pd", d);
    	SmartDashboard.putNumber("Pa", a);
    	SmartDashboard.putNumber("Ppl", p2);
    	SmartDashboard.putNumber("Pil", i2);
    	SmartDashboard.putNumber("Pdl", d2);
    	SmartDashboard.putNumber("Pal", a2);
    	SmartDashboard.putNumber("SRX1 ENC POS", ((RobotMap.driveTrainTalonSRX1.getSelectedSensorVelocity(0)*10*1.04667)/8192));
	     SmartDashboard.putNumber("SRX2 ENC POS", ((RobotMap.driveTrainTalonSRX2.getSelectedSensorVelocity(0)*10*1.04667)/8192));
    	double l = left.calculate(RobotMap.driveTrainTalonSRX1.getSelectedSensorPosition(0));
    	double r = right.calculate(RobotMap.driveTrainTalonSRX2.getSelectedSensorPosition(0));
    	
    	

    	double gyro_heading = RobotMap.gyro.getAngle();//... your gyro code here ...    // Assuming the gyro is giving a value in degrees
    	double desired_heading = Pathfinder.r2d(left.getHeading());  // Should also be in degrees

    	double angleDifference = Pathfinder.boundHalfDegrees(desired_heading - gyro_heading);
    	double turn = 0.8 * (-1.0/80.0) * angleDifference;

    	//RobotMap.driveTrainTalonSRX1.set(-(r - turn));
    	//RobotMap.driveTrainTalonSRX2.set(-(l + turn));
    	//System.out.println(	trajectory.get(counter));
    	SmartDashboard.putNumber("Left Desired", r-turn);
    	SmartDashboard.putNumber("Right Desired", l - turn);
    	if(counter < trajectory.length()){
    		counter++; 
    	}
    	if(left.isFinished()){ 
    		finish = true;
    	}
    	
    	
    }
    
    public void parseArray(){
    	
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return finish;
     }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    	Robot.driveTrain.stop();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
